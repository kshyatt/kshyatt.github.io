[{"authors":null,"categories":null,"content":"Katharine Hyatt is a postdoc, working in the Center for Computational Quantum Physics at the Flatiron Institute, a division of the Simons Foundation. Her research focuses on developing new numerical methods to understand 2D correlated electronic systems, and finding interesting applications in condensed matter physics for these methods. Tensor networks play an important role in this research, along with methods like exact diagonalization and quantum Monte Carlo. She was previously a graduate student at the University of California, Santa Barbara, where she received her PhD in physics in June 2018. Her undergraduate study was completed at the University of Waterloo, from which she holds an Honours BSc in Mathematical Physics. She also moonlights as a sometime Julia language and package developer.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"/author/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/admin/","section":"author","summary":"Katharine Hyatt is a postdoc, working in the Center for Computational Quantum Physics at the Flatiron Institute, a division of the Simons Foundation. Her research focuses on developing new numerical methods to understand 2D correlated electronic systems, and finding interesting applications in condensed matter physics for these methods. Tensor networks play an important role in this research, along with methods like exact diagonalization and quantum Monte Carlo. She was previously a graduate student at the University of California, Santa Barbara, where she received her PhD in physics in June 2018.","tags":null,"title":"","type":"author"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"d41d8cd98f00b204e9800998ecf8427e","permalink":"/author/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/","section":"author","summary":"","tags":null,"title":"Authors","type":"author"},{"authors":["Katharine Hyatt"],"categories":[],"content":" A Journey Through Laziness Quite often, I\u0026rsquo;m working at my desktop in my campus office. The compute cluster on campus does not allow me to SSH directly to nodes or to spawn jobs, so usually you SSH into the head node and queue the jobs (which may be julia jobs, if I want to run some fancy parallel Julia code).\nThis is kind of a pain, so I tried out using ClusterManagers.jl and julia\u0026rsquo;s native addprocs and remote worker functionality to automate this a bit.\nI have key-based login set up from desktop to cluster (the head node), and from cluster to its worker nodes. Let\u0026rsquo;s call my script my_bad_science.jl (I read somewhere that just like in the code itself, your writing about the code should contain descriptive names).\nFirst, I wanted to open a REPL on the desktop (I could make this a script too, of course). All the below examples are julia 0.5.0. Then I opened an SSH tunnel to the cluster:\njulia\u0026gt; addprocs([(\u0026quot;cluster_hostname\u0026quot;,1)], tunnel=true, max_parallel=1, exename=\u0026quot;/home/kshyatt/julia/v0.5/julia\u0026quot;, sshflags=\u0026quot;-vv\u0026quot;)  I passed -vv (verbose) to SSH because otherwise the Julia worker tends to time out. exename is there to tell julia that it\u0026rsquo;s not installed in the same place on the cluster as it is on my desktop.\nThe output looks like:\n# a bunch of verbose SSH chat happens here # removed to protect the guilty/innocent 1-element Array{Int64,1}: 2  Just like any other call to addprocs. Perfect! Now, on the remote head node, which is my worker, I will pull in my script:\n# my bad science script using ClusterManagers.jl # our cluster uses PBS so ClusterManagers.addprocs_pbs(12) # now that the workers will have been loaded # I need to import the packages I need to do # the cool stuff using Distributions using research_utils # a private package of mine #fill up some parameter arrays Ls = collect(8:2:20) w = 10. # disorder strength d = Uniform(-w, w) disorder = [rand(d, L) for L in Ls] Hs = pmap(makeHamiltonians, Ls, disorder) # some code down here to write out the # Hamiltonians to HDF5 - it's gross :(  What this will do is spawn a 12 worker job on the cluster, do the work, and write the results on the cluster. I could also have this script return something to the master worker on my desktop, if I wanted (perhaps timing information?).\nFinally, on my desktop REPL, all I need to do is:\njulia\u0026gt; rr = @spawnat 2 include(\u0026quot;my_bad_science.jl\u0026quot;) Future(2,1,5,Nullable{Any}()) julia\u0026gt; wait(rr)  @spawnat returns a Future, and we need to wait for it to be finished. Or, we could schedule it and merrily go on our way, periodically checking to see if rr is finished.\nOne could also imagine a fancier version of this, plotting data as it comes in from the cluster head node on one\u0026rsquo;s desktop (so we could use something a bit prettier than UnicodePlots.jl). For that you might need a RemoteChannel.\nThis is pretty short but it dramatically improved my lazing about, watching-job-results-come-in workflow. I hope it\u0026rsquo;s useful to someone else!\n","date":1548952064,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548952064,"objectID":"f9b632c06110e44c8a5c028e888706c3","permalink":"/post/sshcluster/","publishdate":"2019-01-31T11:27:44-05:00","relpermalink":"/post/sshcluster/","section":"post","summary":"A Journey Through Laziness Quite often, I\u0026rsquo;m working at my desktop in my campus office. The compute cluster on campus does not allow me to SSH directly to nodes or to spawn jobs, so usually you SSH into the head node and queue the jobs (which may be julia jobs, if I want to run some fancy parallel Julia code).\nThis is kind of a pain, so I tried out using ClusterManagers.","tags":[],"title":"Running Cluster Jobs Remotely ","type":"post"},{"authors":["Katharine Hyatt"],"categories":null,"content":"","date":1548951748,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548951748,"objectID":"4a4bf0b426ed7c8c7bfd98dc3a0af1ae","permalink":"/talk/juliacon2015/","publishdate":"2019-01-31T11:22:28-05:00","relpermalink":"/talk/juliacon2015/","section":"talk","summary":"Using high-performance computing to probe quantum systems is becoming more and more common in condensed matter physics research. Many of the commonly used languages and techniques in this space are either difficult to learn or not performant. Julia has allowed us to quickly develop and test codes for a variety of commonly used algorithms, including exact diagonalization, DMRG, and quantum Monte Carlo. Its parallel features, including MPI and GPGPU integration, make it particularly attractive for many quantum simulations. I’ll discuss what features of Julia have been most useful for us when working on these simulations and the developments we’re most excited about.","tags":[],"title":"Juliacon 2015","type":"talk"},{"authors":["Ann B. Kallin, Katharine Hyatt, Rajiv R. P. Singh, Roger G. Melko"],"categories":null,"content":"","date":1548950477,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548950477,"objectID":"c1e355421cfbe1301f4012ad2e6b9217","permalink":"/publication/nlce/","publishdate":"2019-01-31T11:01:17-05:00","relpermalink":"/publication/nlce/","section":"publication","summary":"We develop a method to calculate the bipartite entanglement entropy of quantum models, in the thermodynamic limit, using a Numerical Linked Cluster Expansion (NLCE) involving only rectangular clusters. It is based on exact diagonalization of all n x m rectangular clusters at the interface between entangled subsystems A and B. We use it to obtain the Renyi entanglement entropy of the two-dimensional transverse field Ising model, for arbitrary real Renyi index alpha. Extrapolating these results as a function of the order of the calculation, we obtain universal pieces of the entanglement entropy associated with lines and corners at the quantum critical point. They show NLCE to be one of the few methods capable of accurately calculating universal properties of arbitrary Renyi entropies at higher dimensional critical points.","tags":[],"title":"Entanglement at a Two-Dimensional Quantum Critical Point: a Numerical Linked Cluster Expansion Study","type":"publication"},{"authors":["Katharine Hyatt, James R. Garrison, Bela Bauer"],"categories":null,"content":"","date":1548950472,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548950472,"objectID":"546e5f96678ea0415d892e70fc83a5e1","permalink":"/publication/disentangling/","publishdate":"2019-01-31T11:01:12-05:00","relpermalink":"/publication/disentangling/","section":"publication","summary":"Tensor networks impose a notion of geometry on the entanglement of a quantum system. In some cases, this geometry is found to reproduce key properties of holographic dualities, and subsequently much work has focused on using tensor networks as tractable models for holographic dualities. Conventionally, the structure of the network - and hence the geometry - is largely fixed a priori by the choice of tensor network ansatz. Here, we evade this restriction and describe an unbiased approach that allows us to extract the appropriate geometry from a given quantum state. We develop an algorithm that iteratively finds a unitary circuit that transforms a given quantum state into an unentangled product state. We then analyze the structure of the resulting unitary circuits. In the case of non-interacting, critical systems in one dimension, we recover signatures of scale invariance in the unitary network, and we show that appropriately defined geodesic paths between physical degrees of freedom exhibit known properties of a hyperbolic geometry.","tags":[],"title":"Extracting Entanglement Geometry from Quantum States","type":"publication"},{"authors":["Katharine Hyatt, James R. Garrison, Andrew C. Potter, Bela Bauer"],"categories":null,"content":"","date":1548950472,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548950472,"objectID":"31b1e1476eda403563e74d032f53dab1","permalink":"/publication/bilayer/","publishdate":"2019-01-31T11:01:12-05:00","relpermalink":"/publication/bilayer/","section":"publication","summary":"In the presence of strong disorder and weak interactions, closed quantum systems can enter a many-body localized phase where the system does not conduct, does not equilibrate even for arbitrarily long times, and robustly violates quantum statistical mechanics. The starting point for such a many-body localized phase is usually taken to be an Anderson insulator where, in the limit of vanishing interactions, all degrees of freedom of the system are localized. Here, we instead consider a model where in the noninteracting limit, some degrees of freedom are localized while others remain delocalized. Such a system can be viewed as a model for a many-body localized system brought into contact with a small bath of a comparable number of degrees of freedom. We numerically and analytically study the effect of interactions on this system and find that generically, the entire system delocalizes. However, we find certain parameter regimes where results are consistent with localization of the entire system, an effect recently termed many-body proximity effect.","tags":[],"title":"Many-body localization in the presence of a small bath","type":"publication"},{"authors":null,"categories":null,"content":" Introduction I get a lot of people who say they want to start contributing to Julia. I link to our spot on Up For Grabs and Iain Dunning\u0026rsquo;s great Contribute To Julia repo. But we don\u0026rsquo;t see a lot of new people opening PRs. I started out a year ago, opening my first PR, and I was so scared. I had no idea what I was doing! Now, I have more than 200 commits to Julia master. I decided to make a detailed pictures-and-text guide of how I:\n Find something to work on in Julia Fix the thing Test my fix Get my local git repo in order Submit a PR Revise and respond to feedback  I use OSX day to day, and all of this should work on Linux too. The steps to get going on Windows are a little more involved but once you have a working Julia build, you are good to go.\nGetting Started - Cloning and Building Julia The first thing you will need is a local clone of the Julia repo. The Julia repo is hosted on Github, and README.md has instructions on how to get started. You can follow along there, or, in most cases (I call my \u0026ldquo;work\u0026rdquo; directory Projects),\ncd ~/Projects git clone https://github.com/JuliaLang/julia.git cd julia make -j 8  I use https because I have 2FA on and I use personal access tokens. SSH is fine too. Since I\u0026rsquo;m on a fancypants iMac, I make with 8 threads (-j 8 tells make how many cores it can use for the build). If this is your first time building julia, now would be a great time to get a coffee. The initial build takes a while.\nIf you\u0026rsquo;re reading this, you probably don\u0026rsquo;t have commit access to Julia. That\u0026rsquo;s fine - we can follow the Github help article on forking. Make sure to add your fork as a remote for your git repo. What I did:\ngit remote add kshyatt https://github.com/kshyatt/julia.git\nI call my own personal forks of things kshyatt and the organizational copy origin, but any name you can remember works.\nMake Sure We\u0026rsquo;re Up To Date During the interim between cloning and building, new commits might have made it into Julia master. We need to make sure we\u0026rsquo;re up to date. I do this using:\ngit checkout master git fetch git status git pull origin master  This gets our master branch up to date with the remote one from origin (in my case from the JuliaLang repo).\nFind Something To Work On Let\u0026rsquo;s head on over to Julia\u0026rsquo;s issues page, which has many issues that take a lot of expert attention. Not all do, though. Usually, problems/feature requests/bugs that are appropriate for new contributors to tackle are filed under the intro-issue label. You can get to it by clicking on the labels header like so:\nI\u0026rsquo;ll pick my own issue, which is about missing features in our linear algebra library. Here\u0026rsquo;s a screencap of it:\nI picked the first item to work on - full doesn\u0026rsquo;t work for Symmetric{SparseMatrixCSC} types! The first thing to do is to make sure this is still a problem, since the issue is kind of old.\nReproducing The Failure Going back to the terminal, I make a test symmetric sparse matrix and attempt to call full on it.\na = sprand(5,5,0.2) #make a 5x5 sparse matrix with random elements a = Symmetric(a + a.') #make it symmetric full(a)  and what did I see, but:\nSo I\u0026rsquo;ve reproduced the failure.\nFinding The Problem The error I got suggests that the problem is with something called copytri!. Symmetric is a tag we put around another matrix type. It\u0026rsquo;s defined in base/linalg/symmetric.jl. Below, I\u0026rsquo;ve opened the file up in vim (or you can go look at the old blob on GitHub):\nWhat the error above tells us is that Julia has no copytri! method that takes a SparseMatrixCSC as an argument. We can see all copytri! methods using the aptly-named methods function:\ncopytri! is not exported from the Base.LinAlg module. There are two methods, and just like the error says, neither method takes SparseMatrixCSC. So we need to:\n Add a copytri! method for sparse matrices Add tests for the method Make sure the method works, fix it if it doesn\u0026rsquo;t Submit a PR  Adding the method It looks like the current copytri! methods all live in base/linalg/matmul.jl. The matrix multiplication methods for sparse matrices all live in base/sparse/linalg.jl, so let\u0026rsquo;s put our function there.\nI opened the sparse file as a pane next to the dense one since we can probably build our new method with some slight modifications to the dense one. This might not have optimal performance, but it\u0026rsquo;s enough to get started.\nFirst, we need to modify the argument list. Our copytri! will take SparseMatrixCSCs as its first argument. We can leave the others untouched for now.\ncopytri! is supposed to copy one triangle of A into the other (since the lower/upper triangles of a symmetric/Hermitian matrix are {c}transposes of each other). The most naive thing we can do is just add the matrix A and its transpose.\nWriting a test The tests for this file are in test/sparsedir/sparse.jl. The top of the file is a pretty reasonable place to put this test. Let\u0026rsquo;s start off with:\nAnd running it shows:\nWelp. Something went wrong here!\n","date":1453939200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1453939200,"objectID":"4068ab8880b390b322bc0d1bff7c46d8","permalink":"/post/2016-01-28-firstpr/","publishdate":"2016-01-28T00:00:00Z","relpermalink":"/post/2016-01-28-firstpr/","section":"post","summary":"Introduction I get a lot of people who say they want to start contributing to Julia. I link to our spot on Up For Grabs and Iain Dunning\u0026rsquo;s great Contribute To Julia repo. But we don\u0026rsquo;t see a lot of new people opening PRs. I started out a year ago, opening my first PR, and I was so scared. I had no idea what I was doing! Now, I have more than 200 commits to Julia master.","tags":null,"title":"Your First Julia Pull Request","type":"post"}]