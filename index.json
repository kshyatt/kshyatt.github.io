[{"authors":null,"categories":null,"content":"Katharine Hyatt is a postdoc, working in the Center for Computational Quantum Physics at the Flatiron Institute, a division of the Simons Foundation. Her research focuses on developing new numerical methods to understand 2D correlated electronic systems, and finding interesting applications in condensed matter physics for these methods. Tensor networks play an important role in this research, along with methods like exact diagonalization and quantum Monte Carlo. She was previously a graduate student at the University of California, Santa Barbara, where she received her PhD in physics in June 2018. Her undergraduate study was completed at the University of Waterloo, from which she holds an Honours BSc in Mathematical Physics. She also moonlights as a sometime Julia language and package developer.\n","date":1548950997,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1548950997,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"https://kshyatt.github.io/author/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/admin/","section":"author","summary":"Katharine Hyatt is a postdoc, working in the Center for Computational Quantum Physics at the Flatiron Institute, a division of the Simons Foundation. Her research focuses on developing new numerical methods to understand 2D correlated electronic systems, and finding interesting applications in condensed matter physics for these methods. Tensor networks play an important role in this research, along with methods like exact diagonalization and quantum Monte Carlo. She was previously a graduate student at the University of California, Santa Barbara, where she received her PhD in physics in June 2018.","tags":null,"title":"","type":"author"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"d41d8cd98f00b204e9800998ecf8427e","permalink":"https://kshyatt.github.io/author/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/","section":"author","summary":"","tags":null,"title":"Authors","type":"author"},{"authors":["Katharine Hyatt"],"categories":[],"content":" In this post I\u0026rsquo;m going to go through my step-by-step process of finding some code in base Julia which is not covered by tests, adding tests which do cover it, checking to make sure the tests pass, and finally opening a pull request to have my changes merged in to Julia itself. We\u0026rsquo;ll be working off commit 0b0a394b3e7741d38f00dbb29895b6ba6a7d0767 if you want to follow along. I do almost all my development on macOS and Linux, so some of the shell commands will be a little different if you\u0026rsquo;re on Windows.\nPrereqs To get started, we\u0026rsquo;re going to need a few things: - Some basic git knowledge: git add, git clone, git commit, git checkout, and git push. If you need an introduction to git, some decent options are: - The GitHub help pages - The official git docs - The codecademy intro to git tutorial, which is free - A source build of Julia, from git clone git@github.com:JuliaLang/julia.git (I use SSH, HTTPS is fine too) - A fork of Julia, since most people making their first pull requests will not have the ability to push branches to the main julia repository.\nZeroth Step: Setting Up Our Fork Having forked the main julia repository to your GitHub account, you\u0026rsquo;re ready to create a local clone and let it know about both the upstream repos. I usually clone julia into a subdirectory of my home directory called projects, so that on a new machine what happens is:\ncd ~ # move to the home directory mkdir -p projects # create the projects directory if it doesn't already exist, otherwise do nothing cd projects # move to the kshyatt/projects directory git clone git@github.com:JuliaLang/julia.git  This will copy the repository from GitHub, including the current state of all the source code as well as all its history. We can look at the remotes of our clone to see other copies of the julia repository our clone is aware of (can fetch/pull/push against). Since we cloned from GitHub, the repository already knows about it:\n~/projects $ cd julia # move down into the julia directory post clone ~/projects/julia $ git remote -v # list remotes and their URLs origin\tgit@github.com:JuliaLang/julia.git (fetch) origin\tgit@github.com:JuliaLang/julia.git (push)  So our repository knows about its \u0026ldquo;parent\u0026rdquo;. But we probably don\u0026rsquo;t have the ability to write directly to the main Julia repositiory (yet \u0026ndash; who knows what the future holds?), which means we won\u0026rsquo;t be able to create our own branches there. Instead, we will need to use a repository copy we do have the ability to write to \u0026ndash; our fork \u0026ndash; to make our coming changes visible to the wide world. If we cloned from the JuliaLang repo, we need to add another remote for our fork. Usually this will have a URL like: https://github.com/$USERNAME/julia.git or git@github.com:$USERNAME/julia.git where $USERNAME is your GitHub username. To let git know about the second remote, we use git remote add:\ngit remote add $REMOTE_NAME git@github.com:$USERNAME/julia.git  $REMOTE_NAME is the local alias we want to call the second remote by. The remote we cloned from (JuliaLang) gets the alias origin. You can pick any alias you like which doesn\u0026rsquo;t conflict with an existing one. I often use kshyatt because even in the grim depths of 3:24am I can usually remember my own name. So when I do the remote add, it looks like:\ngit remote add kshyatt git@github.com:kshyatt/julia.git  And afterwards, if we look at the remotes git knows about:\n~/projects/julia $ git remote -v # list remotes and their URLs kshyatt\tgit@github.com:kshyatt/julia.git (fetch) kshyatt\tgit@github.com:kshyatt/julia.git (push) origin\tgit@github.com:JuliaLang/julia.git (fetch) origin\tgit@github.com:JuliaLang/julia.git (push)  With a fork and local knowledge of it, we\u0026rsquo;re ready to find some changes to make.\nThe Hunt for Red Lines There are many kinds of contributions a person can make to an open source project:\n New features Performance improvements Bug fixes Test coverage Documentation improvements Usage examples  If you\u0026rsquo;re just starting out contributing to Julia, and don\u0026rsquo;t have an obvious idea for a feature or a performance enhancement you could write, writing tests or improving docs are a great way to get started. People often disagree about the desirability of a new feature but I almost never see anyone say we should have fewer tests! Writing tests is a good way to learn how Julia works \u0026ndash; or doesn\u0026rsquo;t, if you find a bug. We don\u0026rsquo;t want to write tests just for the sake of having them, though \u0026ndash; we want to test as many julia features as possible in as little time as possible. If we\u0026rsquo;re writing new tests, it\u0026rsquo;s always a good idea to keep the test coverage in mind. Test coverage measures which lines of base (and stdlib) Julia are exercised by the tests. We keep this information current at codecov. Here\u0026rsquo;s a screenshot:\nWe can see the attractive sunburst picture, and a history of recent commits showing their total coverage percentage. On a lark, I picked base/ to go hunting for uncovered lines.\nHere we see each file, with its total lines, covered lines, uncovered lines, and coverage percentage. If we want to increase coverage, we want to pick a file with less than 100% of its lines covered. Keep in mind that these numbers may be less than the true coverage, because right now the coverage-enabled runs of the tests are all done on Unix and some code in Julia is Windows or BSD specific. Tests for such code aren\u0026rsquo;t run by the coverage measurement script.\nI happened to scroll down until I came across base/secretbuffer.jl. This file had a lot of uncovered lines, so I thought I had a decent chance of finding some code I could write tests to cover:\nClicking on the Codecov link opens up an annotated version of the source file, with green coloring representing lines which are covered by tests, and red coloring representing lines which are not. Scrolling down the file, I came across the write method, which writes some data packed into a UInt8 into the secret buffer\u0026rsquo;s data:\nIn order to test this, it would probably be good to have some sense of what it does. Having been using Julia since 2015, I probably have a bad heuristic for how easy this is to understand \u0026ndash; if you are looking at it and can\u0026rsquo;t figure it out in about 5 minutes, there\u0026rsquo;s absolutely no shame in logging onto the Julia Slack and asking! We have #my-first-pr and #helpdesk channels exactly for this. The type itself is defined earlier in the file:\nmutable struct SecretBuffer \u0026lt;: IO data::Vector{UInt8} size::Int ptr::Int function SecretBuffer(; sizehint=128) s = new(Vector{UInt8}(undef, sizehint), 0, 1) finalizer(final_shred!, s) return s end end  My attempt at an explanation\n SecretBuffer, like the name implies, is a type which contains some data which you\u0026rsquo;d like to keep secret from prying eyes It contains information about the total amount of information stored, in the size field It contains information about where in the data we are currently reading or writing - the pointer field  This analogy is a little fuzzy, but if you\u0026rsquo;re confused, imagine the buffer is a piece of paper on which we\u0026rsquo;ve written a message in code. The size is the total number of letters in the message, and the pointer is the letter we are trying to encode or decode at the moment. Then the write function attempts to insert an unsigned 8 bit integer b at the ptr of the input SecretBuffer. The uncovered lines are there to deal with the case where the SecretBuffer\u0026rsquo;s data array is totally full (the ptr is past its length). In the paper analogy, this would mean that we wrote all the way to the bottom right corner and need to turn over to a fresh page.\nWriting the test To test this case, what I chose to do was:\n Create a small SecretBuffer and write up to its data size Write a little more data, so that it will have to call this untested code and extend data in-place Make sure all the data I wrote survived the process  Julia\u0026rsquo;s tests live in the test/ directory, which is in the top-level with base/ and stdlib/. From my julia clone, I can see what it contains:\nls ~/projects/julia/test  If you do this, you\u0026rsquo;ll see there is a file called test/secretbuffer.jl. That looks promising, and indeed, it\u0026rsquo;s where tests for SecretBuffer are (as opposed to tests for another kind of buffer, put there as a prank). Now you can open your favorite text editor and modify the file. I like to see if there is an obvious place to add the tests in the file \u0026ndash; for example, if I\u0026rsquo;m testing a function for subtracting complex numbers, and there are already a bunch of tests for adding them, that would be a natural location to add my test.\nJulia test files tend to be organized into testsets, which group similar tests and make it easier to pinpoint where the problem is when one fails. Since we\u0026rsquo;re testing something specific, it makes sense to add our own little testset nested inside the main SecretBuffers testset (as the others are):\n@testset \u0026quot;write! past data size\u0026quot; begin # ready to test some stuff in here! end  Testsets get a name, so that if they fail we can see what\u0026rsquo;s broken. It\u0026rsquo;s best to write something descriptive for this rather than \u0026ldquo;aaaaa\u0026rdquo;, \u0026ldquo;aaaab\u0026rdquo;, etc. Following what I wrote above, I need to create a small SecretBuffer\u0026hellip;\n@testset \u0026quot;write! past data size\u0026quot; begin sb = SecretBuffer(sizehint=2) end  Where sizehint tells Julia how big to make the initial internal data array (you can see this in the type definition I copied above). Now I need to write some data to the buffer to read the end of the data array, which has two slots currently. I picked the biggest integer UInt8 can represent, because its bits will all be non-zero (here I am anticipating what I\u0026rsquo;m going to test at the end).\n@testset \u0026quot;write! past data size\u0026quot; begin sb = SecretBuffer(sizehint=2) # data vector will not grow bits = typemax(UInt8) write(sb, bits) write(sb, bits) end  Now the data vector is fully saturated, and we will test the growing part of it by trying to write one more time:\n@testset \u0026quot;write! past data size\u0026quot; begin sb = SecretBuffer(sizehint=2) # data vector will not grow bits = typemax(UInt8) write(sb, bits) write(sb, bits) # data vector must grow write(sb, bits) end  Finally, it would be good to make sure this write didn\u0026rsquo;t silently fail somehow or corrupt the previously written data, so we are going to read back the buffer and make sure its contents are what we expect, which is a String with three identical elements:\n@testset \u0026quot;write! past data size and unsafe_convert\u0026quot; begin sb = SecretBuffer(sizehint=2) # data vector will not grow bits = typemax(UInt8) write(sb, bits) write(sb, bits) # data vector must grow write(sb, bits) seek(sb, 0) @test read(sb, String) == \u0026quot;\\xff\\xff\\xff\u0026quot; shred!(sb) end  We seek back to the start of the data to make sure we capture all three elements. We read the buffer as a String and compare with what the result should be. How did I know it would be three \\xff?\njulia\u0026gt; String([typemax(UInt8)]) \u0026quot;\\xff\u0026quot;  We can make sure the test works by running it. I nearly always use the Makefile to do this, because it will catch whitespace errors, which I make prodiguously.\ncd ~/projects/julia make test-secretbuffer  You can run any test in test/ this way, for example make test-arrayops works too. Assuming the tests pass, we are ready to commit and move on. If they don\u0026rsquo;t pass, you\u0026rsquo;ll need to look at the error message and try to figure out how to fix the test and/or the code it\u0026rsquo;s supposed to be testing.\nCommiting and pushing We need to commit our changes and push them to a remote so that we can open a pull request, which will let someone review the proposed changes and (hopefully) merge them. Although it\u0026rsquo;s possible to do this from your master branch, this can very quickly lead to tears. It\u0026rsquo;s better to: 1. Make a new git branch 2. Commit the changes there 3. Push that branch to your fork 4. Open a pull request from the branch on your fork We can use git checkout -b to both create a new branch and move over onto it, which will drag all our changes along with. git checkout -b is a shorter way of saying git branch $BRANCH_NAME \u0026amp;\u0026amp; git checkout $BRANCH_NAME. You can choose whatever you like for the branch name, but I tend to prepend with my initials and then use a short description of what the changes were. As an example:\ngit checkout -b ksh/sbtest  Now we\u0026rsquo;re ready to commit. Since the change was just to one file, and pretty small, we can do a command-line commit and bypass the editor. We\u0026rsquo;ll commit and pass the -m flag with an accompanying commit message, which will tell everyone what the changes do.\ngit commit test/secretbuffer.jl -m \u0026quot;Added test for write-ing past the pre-existing data length\u0026quot;  I told git which file(s) to use in the commit and the message to attach to them. The commit will be made to the ksh/sbtest branch. Now I\u0026rsquo;m ready to push. Because, for the purposes of this example, I don\u0026rsquo;t have write access to JuliaLang/julia, I will push to my fork at kshyatt/julia and open the pull request from there. All I have to do is tell git to push to the kshyatt remote I created at the start of this post.\n~/projects/julia $ git push kshyatt ksh/sbtest Enumerating objects: 7, done. Counting objects: 100% (7/7), done. Delta compression using up to 8 threads Compressing objects: 100% (4/4), done. Writing objects: 100% (4/4), 613 bytes | 306.00 KiB/s, done. Total 4 (delta 3), reused 0 (delta 0) remote: Resolving deltas: 100% (3/3), completed with 3 local objects. remote: remote: Create a pull request for 'ksh/sbtest' on GitHub by visiting: remote: https://github.com/kshyatt/julia/pull/new/ksh/sbtest remote: To github.com:kshyatt/julia.git * [new branch] ksh/sbtest -\u0026gt; ksh/sbtest  Hooray! The push to my remote succeeded. The changes have been propagated \u0026ldquo;upstream\u0026rdquo; and can be used to open the pull request.\nImportant Note: Make sure to open the pull request from JuliaLang/julia, and not from your fork!\nTo open the PR, I open up the main Julia repo and lo and behold, GitHub has a suggestion for me! I sure do want to make this pull request, so I hit the green button that says \u0026ldquo;Compare and Pull Request\u0026rdquo;.\nThat leads to the comparison screen, where I can see my proposed changes and write some comments describing what they do.\nGitHub has also helpfully used my commit message to title the pull request, and I think it\u0026rsquo;s quite a nice title so I will leave it be. This PR is pretty self-explanatory so I won\u0026rsquo;t write a description in the big text box provided, but it doesn\u0026rsquo;t hurt to do this if you think it might not be obvious what your code does. Don\u0026rsquo;t worry about requesting a reviewer or adding labels if this is your first PR - a maintainer can handle that for you. If everything looks ok, press the \u0026ldquo;Create pull request\u0026rdquo; button. At this point, you can wait for some reviews and maintainers can give you detailed help if your PR needs some changes. It\u0026rsquo;s very common for a PR to need some tweaks \u0026ndash; it happens to me all the time! Although it can feel a little discouraging to have to keep making changes, maintainers are devoting the time to re-reviewing your PR because they think it\u0026rsquo;s good and want it to be the best it can be (just like Julia as a whole). If you want to see the real-life PR that I created in making this post, it\u0026rsquo;s right here.\nLess than half a minute after I opened the pull request, super speedy reviewer Matt Baumann thought it was alright to merge it.\nNow we just had to wait for the continuous integration (CI) servers to run the tests. There are CI servers for Windows, Linux, macOS, ARM, and freeBSD. If \u0026ldquo;the lights turn green\u0026rdquo; (all tests passed), and someone has approved the PR, it should be merged very soon. If 24 hours have passed and it hasn\u0026rsquo;t been merged, feel free to ping the person who approved the PR and ask them if they can merge it for you. Sometimes these things fall by the wayside. Even if CI fails, it may be an incidental failure unrelated to your changes. If it is related, someone will be happy to help you figure out what the problem is, or you can dig through the logs yourself to try to figure it out. If no one reviews your PR after a day or two, you can post a comment on the PR asking for review, or come onto Slack and bug us about it.\n","date":1548959966,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548968698,"objectID":"3cc9b4da6386823a768b3fa8fcedf796","permalink":"https://kshyatt.github.io/post/firstjuliapr/","publishdate":"2019-01-31T13:39:26-05:00","relpermalink":"/post/firstjuliapr/","section":"post","summary":"In this post I\u0026rsquo;m going to go through my step-by-step process of finding some code in base Julia which is not covered by tests, adding tests which do cover it, checking to make sure the tests pass, and finally opening a pull request to have my changes merged in to Julia itself. We\u0026rsquo;ll be working off commit 0b0a394b3e7741d38f00dbb29895b6ba6a7d0767 if you want to follow along. I do almost all my development on macOS and Linux, so some of the shell commands will be a little different if you\u0026rsquo;re on Windows.","tags":[],"title":"Making a first Julia pull request","type":"post"},{"authors":["Katharine Hyatt"],"categories":null,"content":"","date":1548959150,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548968416,"objectID":"018391579050435f7beb4b61b4922fcb","permalink":"https://kshyatt.github.io/talk/juliacon2017/","publishdate":"2019-01-31T13:25:50-05:00","relpermalink":"/talk/juliacon2017/","section":"talk","summary":"Start using Julia to do simulations of quantum systems with many interacting particles! We will write a single-core exact diagonalization code which can handle a variety of models from quantum physics, using Julia to make it readable and performant. We'll tour the Julia package ecosystem for useful packages that will help us store our results to share with others and get to the interesting physics. Then, we'll use some of Julia's parallel features to scale up our code to do many-body simulation on many-core and many-node systems in a convenient, reproducible, and fast way. You need not ever have written any Julia before. We'll use physics examples as natural motivation to explore Julia's capabilities, but no background in quantum mechanics is required. We will introduce the models as we go.","tags":[],"title":"From One To Many","type":"talk"},{"authors":["Katharine Hyatt"],"categories":[],"content":" A Journey Through Laziness Quite often, I\u0026rsquo;m working at my desktop in my campus office. The compute cluster on campus does not allow me to SSH directly to nodes or to spawn jobs, so usually you SSH into the head node and queue the jobs (which may be julia jobs, if I want to run some fancy parallel Julia code).\nThis is kind of a pain, so I tried out using ClusterManagers.jl and julia\u0026rsquo;s native addprocs and remote worker functionality to automate this a bit.\nI have key-based login set up from desktop to cluster (the head node), and from cluster to its worker nodes. Let\u0026rsquo;s call my script my_bad_science.jl (I read somewhere that just like in the code itself, your writing about the code should contain descriptive names).\nFirst, I wanted to open a REPL on the desktop (I could make this a script too, of course). All the below examples are julia 0.5.0. Then I opened an SSH tunnel to the cluster:\njulia\u0026gt; addprocs([(\u0026quot;cluster_hostname\u0026quot;,1)], tunnel=true, max_parallel=1, exename=\u0026quot;/home/kshyatt/julia/v0.5/julia\u0026quot;, sshflags=\u0026quot;-vv\u0026quot;)  I passed -vv (verbose) to SSH because otherwise the Julia worker tends to time out. exename is there to tell julia that it\u0026rsquo;s not installed in the same place on the cluster as it is on my desktop.\nThe output looks like:\n# a bunch of verbose SSH chat happens here # removed to protect the guilty/innocent 1-element Array{Int64,1}: 2  Just like any other call to addprocs. Perfect! Now, on the remote head node, which is my worker, I will pull in my script:\n# my bad science script using ClusterManagers.jl # our cluster uses PBS so ClusterManagers.addprocs_pbs(12) # now that the workers will have been loaded # I need to import the packages I need to do # the cool stuff using Distributions using research_utils # a private package of mine #fill up some parameter arrays Ls = collect(8:2:20) w = 10. # disorder strength d = Uniform(-w, w) disorder = [rand(d, L) for L in Ls] Hs = pmap(makeHamiltonians, Ls, disorder) # some code down here to write out the # Hamiltonians to HDF5 - it's gross :(  What this will do is spawn a 12 worker job on the cluster, do the work, and write the results on the cluster. I could also have this script return something to the master worker on my desktop, if I wanted (perhaps timing information?).\nFinally, on my desktop REPL, all I need to do is:\njulia\u0026gt; rr = @spawnat 2 include(\u0026quot;my_bad_science.jl\u0026quot;) Future(2,1,5,Nullable{Any}()) julia\u0026gt; wait(rr)  @spawnat returns a Future, and we need to wait for it to be finished. Or, we could schedule it and merrily go on our way, periodically checking to see if rr is finished.\nOne could also imagine a fancier version of this, plotting data as it comes in from the cluster head node on one\u0026rsquo;s desktop (so we could use something a bit prettier than UnicodePlots.jl). For that you might need a RemoteChannel.\nThis is pretty short but it dramatically improved my lazing about, watching-job-results-come-in workflow. I hope it\u0026rsquo;s useful to someone else!\n","date":1548952064,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548952194,"objectID":"f9b632c06110e44c8a5c028e888706c3","permalink":"https://kshyatt.github.io/post/sshcluster/","publishdate":"2019-01-31T11:27:44-05:00","relpermalink":"/post/sshcluster/","section":"post","summary":"A Journey Through Laziness Quite often, I\u0026rsquo;m working at my desktop in my campus office. The compute cluster on campus does not allow me to SSH directly to nodes or to spawn jobs, so usually you SSH into the head node and queue the jobs (which may be julia jobs, if I want to run some fancy parallel Julia code).\nThis is kind of a pain, so I tried out using ClusterManagers.","tags":[],"title":"Running Cluster Jobs Remotely ","type":"post"},{"authors":["Katharine Hyatt"],"categories":null,"content":"","date":1548951748,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548951890,"objectID":"4a4bf0b426ed7c8c7bfd98dc3a0af1ae","permalink":"https://kshyatt.github.io/talk/juliacon2015/","publishdate":"2019-01-31T11:22:28-05:00","relpermalink":"/talk/juliacon2015/","section":"talk","summary":"Using high-performance computing to probe quantum systems is becoming more and more common in condensed matter physics research. Many of the commonly used languages and techniques in this space are either difficult to learn or not performant. Julia has allowed us to quickly develop and test codes for a variety of commonly used algorithms, including exact diagonalization, DMRG, and quantum Monte Carlo. Its parallel features, including MPI and GPGPU integration, make it particularly attractive for many quantum simulations. I’ll discuss what features of Julia have been most useful for us when working on these simulations and the developments we’re most excited about.","tags":[],"title":"Juliacon 2015","type":"talk"},{"authors":["Ann B. Kallin, Katharine Hyatt, Rajiv R. P. Singh, Roger G. Melko"],"categories":null,"content":"","date":1548950477,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548950997,"objectID":"c1e355421cfbe1301f4012ad2e6b9217","permalink":"https://kshyatt.github.io/publication/nlce/","publishdate":"2019-01-31T11:01:17-05:00","relpermalink":"/publication/nlce/","section":"publication","summary":"We develop a method to calculate the bipartite entanglement entropy of quantum models, in the thermodynamic limit, using a Numerical Linked Cluster Expansion (NLCE) involving only rectangular clusters. It is based on exact diagonalization of all n x m rectangular clusters at the interface between entangled subsystems A and B. We use it to obtain the Renyi entanglement entropy of the two-dimensional transverse field Ising model, for arbitrary real Renyi index alpha. Extrapolating these results as a function of the order of the calculation, we obtain universal pieces of the entanglement entropy associated with lines and corners at the quantum critical point. They show NLCE to be one of the few methods capable of accurately calculating universal properties of arbitrary Renyi entropies at higher dimensional critical points.","tags":[],"title":"Entanglement at a Two-Dimensional Quantum Critical Point: a Numerical Linked Cluster Expansion Study","type":"publication"},{"authors":["Katharine Hyatt, James R. Garrison, Bela Bauer"],"categories":null,"content":"","date":1548950472,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548950997,"objectID":"546e5f96678ea0415d892e70fc83a5e1","permalink":"https://kshyatt.github.io/publication/disentangling/","publishdate":"2019-01-31T11:01:12-05:00","relpermalink":"/publication/disentangling/","section":"publication","summary":"Tensor networks impose a notion of geometry on the entanglement of a quantum system. In some cases, this geometry is found to reproduce key properties of holographic dualities, and subsequently much work has focused on using tensor networks as tractable models for holographic dualities. Conventionally, the structure of the network - and hence the geometry - is largely fixed a priori by the choice of tensor network ansatz. Here, we evade this restriction and describe an unbiased approach that allows us to extract the appropriate geometry from a given quantum state. We develop an algorithm that iteratively finds a unitary circuit that transforms a given quantum state into an unentangled product state. We then analyze the structure of the resulting unitary circuits. In the case of non-interacting, critical systems in one dimension, we recover signatures of scale invariance in the unitary network, and we show that appropriately defined geodesic paths between physical degrees of freedom exhibit known properties of a hyperbolic geometry.","tags":[],"title":"Extracting Entanglement Geometry from Quantum States","type":"publication"},{"authors":["Katharine Hyatt, James R. Garrison, Andrew C. Potter, Bela Bauer"],"categories":null,"content":"","date":1548950472,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548950997,"objectID":"31b1e1476eda403563e74d032f53dab1","permalink":"https://kshyatt.github.io/publication/bilayer/","publishdate":"2019-01-31T11:01:12-05:00","relpermalink":"/publication/bilayer/","section":"publication","summary":"In the presence of strong disorder and weak interactions, closed quantum systems can enter a many-body localized phase where the system does not conduct, does not equilibrate even for arbitrarily long times, and robustly violates quantum statistical mechanics. The starting point for such a many-body localized phase is usually taken to be an Anderson insulator where, in the limit of vanishing interactions, all degrees of freedom of the system are localized. Here, we instead consider a model where in the noninteracting limit, some degrees of freedom are localized while others remain delocalized. Such a system can be viewed as a model for a many-body localized system brought into contact with a small bath of a comparable number of degrees of freedom. We numerically and analytically study the effect of interactions on this system and find that generically, the entire system delocalizes. However, we find certain parameter regimes where results are consistent with localization of the entire system, an effect recently termed many-body proximity effect.","tags":[],"title":"Many-body localization in the presence of a small bath","type":"publication"}]